<!DOCTYPE html>
<html lang="zh-CN">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <link rel="shortcut icon" href="/img/favicon.ico">
  <link rel="stylesheet" href="/css/normalize.css">
  <link rel="stylesheet" href="/css/Torpedo.css">
  <link rel="stylesheet" href="/css/yewmint.css">
  <title>Threading Building Blocks(TBB) | Yewth</title>
</head>

  <body>
    <div id="wrapper">
      <header id="page-header">
  <div id="header-title">
    <a href="/">Yewth</a>
  </div>
  <div id="header-nav">
    <ul>
      
        <li><a target="_blank" class="menu-item " href="/">Index</a></li>
      
        <li><a target="_blank" class="menu-item " href="https://github.com/yewmint">GITHUB</a></li>
      
    </ul>
</header>

      <article class="article">
  <h1 id="-" class="article-title">Threading Building Blocks(TBB)</h1>
  <p class="article-date">2017-10-08</p>
  <p>Threading Building Blocks(TBB)是Intel推出的并行编程API。TBB的特点是在多线程基础上，构建了一层逻辑并行API。用户只需要关注逻辑任务，不需要对多线程有深入理解。相比于直接调用系统多线程API，TBB的编程效率和执行效率都得到了提高。</p>
<a id="more"></a>
<h2 id="1-数据并行"><a href="#1-数据并行" class="headerlink" title="1. 数据并行"></a>1. 数据并行</h2><p>传统多线程思路中，将程序的不同步骤在不同线程中执行，称为<strong>过程并行</strong>。TBB提倡<strong>数据并行</strong>，即将大块数据分为不同部分，分别在不同线程中执行操作。TBB会自动根据CPU的情况优化数据块的分割，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">parallel_for(<span class="keyword">size_t</span>(<span class="number">0</span>), n, [=](<span class="keyword">size_t</span> i) &#123; func(i); &#125;);</div></pre></td></tr></table></figure>
<p>类似还有<code>parallel_reduce</code>等函数。而对于未知长度的数据，可以利用<code>parallel_do</code>来遍历。</p>
<h2 id="2-并行数据流和依赖图"><a href="#2-并行数据流和依赖图" class="headerlink" title="2. 并行数据流和依赖图"></a>2. 并行数据流和依赖图</h2><p>计算机科学中，计算机图形学是极度依赖并行的。Vertex Shader中并行计算的数据，会并行地传输到Fragment Shader中继续计算。TBB也提供了类似的<strong>并行数据流(Parallelizing Data Flow)</strong>，可以将并行计算分散到各个不同节点中，通过传输通道将数据互相发送。而依赖图则是对并行数据流的反向计算。</p>
<h2 id="3-容器"><a href="#3-容器" class="headerlink" title="3. 容器"></a>3. 容器</h2><p>STL中的容器对并行支持不够，并行修改数据会导致容器崩溃。TBB提供了<code>concurrent_hash_map</code>和<code>concurrent_vector</code>，这两个容器都支持并行写入操作。</p>
<h2 id="4-内存分配"><a href="#4-内存分配" class="headerlink" title="4. 内存分配"></a>4. 内存分配</h2><p>TBB附带了一个内存分配库<strong>Scalable Memory Allocator</strong>，提供了几个实用功能。</p>
<h3 id="4-1-内存并行分配"><a href="#4-1-内存并行分配" class="headerlink" title="4.1 内存并行分配"></a>4.1 内存并行分配</h3><p>由于多线程共享一个内存池，所以传统的内存分配是互斥的，TBB提供<code>scalable_allocator&lt;T&gt;</code>用于并行分配内存，在需要反复分配、释放内存的地方，会显著提升性能。</p>
<h3 id="4-2-伪共享"><a href="#4-2-伪共享" class="headerlink" title="4.2 伪共享"></a>4.2 伪共享</h3><p>多个处理器在访问不同的变量时，可能遇到变量刚好位于同一缓存行的情况，没有当前缓存行访问权限的那个处理器，不得不等待缓存切换。这种情况称为<strong>伪共享</strong>。TBB提供了<code>cache_aligned_allocator&lt;T&gt;</code>，通过在变量后填充，将长度固定为一个缓存行的大小，保证不同变量一定在不同的缓存行。由于这种方法浪费大量缓存空间，尽量只在伪共享影响严重的地方使用。</p>
<h3 id="4-3-内存分配代理"><a href="#4-3-内存分配代理" class="headerlink" title="4.3 内存分配代理"></a>4.3 内存分配代理</h3><p>Scalable Memory Allocator还提供了一个内存分配代理库，通过导入库和头文件，将<code>new/free/malloc</code>等内存分配操作符或函数替换为<code>scalable_allocator&lt;T&gt;</code>。因此以前的代码可以无缝切换到TBB。</p>
<h2 id="5-杂项"><a href="#5-杂项" class="headerlink" title="5. 杂项"></a>5. 杂项</h2><p>对于锁、同步和竞争等多线程容易出现的问题，TBB都提供了接口进行控制。而多线程的异常和生命周期管理也有相应的接口。</p>
<p>Intel提出了一套TBB设计模式，这套模式可以使得程序更有效地利用TBB所带来的优势。这套模式在<a href="https://software.intel.com/en-us/node/506112" target="_blank" rel="external">这里</a>可以看到。</p>
<p>Intel也特别提出，对于非Intel处理器，TBB不保证可用和稳定。</p>
<p><strong>全文完</strong></p>

</article>

      <footer>
  <div class="footer">
    &copy; 2015-2016 Yewmint, All rights reserved.
  </div>
</footer>

    </div>
  </body>
</html>
