<!DOCTYPE html>
<html lang="zh-CN">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <link rel="shortcut icon" href="/img/favicon.ico">
  <link rel="stylesheet" href="/css/normalize.css">
  <link rel="stylesheet" href="/css/Torpedo.css">
  <link rel="stylesheet" href="/css/yewmint.css">
  <title>多边形交集 | Yewth</title>
</head>

  <body>
    <div id="wrapper">
      <header id="page-header">
  <div id="header-title">
    <a href="/">Yewth</a>
  </div>
  <div id="header-nav">
    <ul>
      
        <li><a target="_blank" class="menu-item " href="/">Index</a></li>
      
        <li><a target="_blank" class="menu-item " href="https://github.com/yewmint">GITHUB</a></li>
      
    </ul>
</header>

      <article class="article">
  <h1 id="-" class="article-title">多边形交集</h1>
  <p class="article-date">2017-03-15</p>
  <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>给定两个多边形，求它们的交集，如下图所示</p>
<p><img src="http://tuch.oss-cn-shanghai.aliyuncs.com/Untitled-1.png" alt="intersect"></p>
<p>点击<a href="/demos/polyinter.html">demo</a>查看效果，包含两种算法<br>源码在<a href="https://github.com/yewmint/polyinter" target="_blank" rel="external">github</a></p>
<a id="more"></a>
<p>在分析这个问题之前，我们约定：</p>
<ol>
<li>多边形的线段均为向量</li>
<li>多边形方向朝向z轴正向</li>
</ol>
<p>图上两个多边形，我们称绿色多边形为<strong>切多边形</strong>，称蓝色多边形为<strong>原多边形</strong><br>交集即相当于绿色多边形在蓝色多边形上的切割</p>
<h2 id="交集多边形"><a href="#交集多边形" class="headerlink" title="交集多边形"></a>交集多边形</h2><p>由于交集是由两个多边形的一些边组成，所以它仍然是一个多边形</p>
<p>于是问题就转化为<strong>找到构成交集多边形的边</strong></p>
<p>可以构造如下算法：</p>
<ol>
<li>从两个多边形的某个交点朝正向出发，走一条满足2或者3的路径</li>
<li>顺着原多边形的边前进，进入了切多边形</li>
<li>顺着切多边形的边前进，进入了原多边形</li>
</ol>
<p>当我们回到最初的交点，走过的边则构成了交集多边形</p>
<h2 id="线段交点的出入性"><a href="#线段交点的出入性" class="headerlink" title="线段交点的出入性"></a>线段交点的出入性</h2><p><img src="http://tuch.oss-cn-shanghai.aliyuncs.com/Untitled-2.png" alt="intersect"></p>
<p>以上算法中，2、3步涉及到交点的出入性，比较费解</p>
<p>这里，我们作两个定义：</p>
<blockquote>
<p>出点：交点处按切多边形正向前进，会从原多边形内部出到外部<br>入点：交点处按切多边形正向前进，会从原多边形外部进到内部</p>
</blockquote>
<p>则上图中，红色交点为出点，紫色交点为入点</p>
<p>于是算法的2、3步可以改写如下：</p>
<ol>
<li>如果当前节点是出点，则顺着原多边形正向前进</li>
<li>如果当前结点是入点，则顺着切多边形正向前进</li>
</ol>
<p><img src="http://tuch.oss-cn-shanghai.aliyuncs.com/3.png" alt="intersect"></p>
<p>我们继续使用上一篇文章中的算法求交点，为了获得交点的出入性，<br>我们设产生交点的两条向量v1和v2，分别是切多边形和原多边形的边</p>
<p>如上图所示</p>
<p>作v1的a点到v2的a点的向量va，v1的a点到v2的b点的向量vb<br>此时计算<code>va x vb</code>，由向量计算，可知叉乘z分量大于零<br>故此交点为出点</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># inout.coffee</div><div class="line">va = new vec(v1.a, v2.a)</div><div class="line">vb = new vec(v1.a, v2.b)</div><div class="line">vc = crossProduct(va, vb)</div><div class="line">if vc.z &gt; 0</div><div class="line">  return &apos;out&apos;</div><div class="line">else</div><div class="line">  return &apos;in&apos;</div></pre></td></tr></table></figure>
<p>同理可以求得入点</p>
<h2 id="另一种思路"><a href="#另一种思路" class="headerlink" title="另一种思路"></a>另一种思路</h2><p>上述算法描述简洁，可以适应任意多边形，<br>但是实现困难，判断下一个交点的条件过多，而且在临界值的处理上十分容易出错</p>
<p>这里我们如果从交点考虑，一个交集多边形是由点集组成，点集包含：</p>
<ol>
<li>交点</li>
<li>原多边形在切多边形中的点</li>
<li>切多边形在原多边形中的点</li>
</ol>
<p>为了求点是否在多边形内，我们设两个多边形都是凸多边形<br>则当点p在所有线段向量的左侧时，p包含在多边形内</p>
<p>求点p在向量左侧的算法类似于出入点，如果已知交点为出点，则上图中v1的起点必在左侧：</p>
<p><img src="http://tuch.oss-cn-shanghai.aliyuncs.com/4.png" alt="intersect"></p>
<p>设点p，线段v，同上取va、vb，叉乘z分量大于0时，点p在线段v左侧：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># left.coffee</div><div class="line">va = new vec(p, v2.a)</div><div class="line">vb = new vec(p, v2.b)</div><div class="line">vc = crossProduct(va, vb)</div><div class="line">if vc.z &gt; 0</div><div class="line">  return &apos;left&apos;</div><div class="line">else</div><div class="line">  return &apos;right&apos;</div></pre></td></tr></table></figure>
<p>这种方法要求多边形均为凸多边形，对于凹多边形可以通过凸切割的方法把它切成多个凸多边形</p>
<p><strong>全文完</strong></p>

</article>

      <footer>
  <div class="footer">
    &copy; 2015-2016 Yewmint, All rights reserved.
  </div>
</footer>

    </div>
  </body>
</html>
