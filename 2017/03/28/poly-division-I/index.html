<!DOCTYPE html>
<html lang="zh-CN">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <link rel="shortcut icon" href="/img/favicon.ico">
  <link rel="stylesheet" href="/css/normalize.css">
  <link rel="stylesheet" href="/css/Torpedo.css">
  <link rel="stylesheet" href="/css/yewmint.css">
  <title>凹多边形的凸切分 EP1 | Yewth</title>
</head>

  <body>
    <div id="wrapper">
      <header id="page-header">
  <div id="header-title">
    <a href="/">Yewth</a>
  </div>
  <div id="header-nav">
    <ul>
      
        <li><a target="_blank" class="menu-item " href="/">Index</a></li>
      
        <li><a target="_blank" class="menu-item " href="https://github.com/yewmint">GITHUB</a></li>
      
    </ul>
</header>

      <article class="article">
  <h1 id="-" class="article-title">凹多边形的凸切分 EP1</h1>
  <p class="article-date">2017-03-28</p>
  <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在几何计算中，将多边形假设为凸多边形可以简化计算<br>但是在实际应用里面，凹多边形要常见许多</p>
<p>为了在凹多边形中应用凸多边形的算法，可以构造一个<strong>凸切分算法</strong>，<br>把凹多边形切割多个凸多边形</p>
<p><img src="//tuch.oss-cn-shanghai.aliyuncs.com/5.png" alt="division"></p>
<a id="more"></a>
<p>演示用的Demo在这里：<a href="/demos/polydivision.html">Demo</a></p>
<h2 id="切分凹角"><a href="#切分凹角" class="headerlink" title="切分凹角"></a>切分凹角</h2><p>有一个角的内角大于180度，这是凹多边形最明显的特征，称为<strong>凹角</strong><br>首先尝试通过切分去掉所有的凹角</p>
<p>设当前边为<code>s0</code>，后续第n条边为<code>sn</code><br>通过差乘<code>(s0 x s1).z &lt; 0</code>判断当前边和下一条边之间的角是否为凹角</p>
<p>如果边<code>s0</code>的下一个角为凹角，则遍历之后所有的点<code>pt</code><br>当<code>(s0 x (s0.b, pt)).z &gt; 0</code>时，则意味着划线<code>(s0.b, pt)</code>，可以将当前的凹角切分为凸角</p>
<p>由此思路可以得到<code>Slice A</code>算法，可以在DEMO中试验</p>
<h2 id="切分线交叉"><a href="#切分线交叉" class="headerlink" title="切分线交叉"></a>切分线交叉</h2><p>从<code>Slice A</code>可以看出，这种方法会产生相交的切线<br>一般来说不会产生什么问题，因为可以把交点当作新的顶点<br>生成的多个多边形确实是凸多边形</p>
<p>当条件不允许生成新顶点的时候，一些额外处理可以避免这种情况出现</p>
<p>这种切线的产生，是因为我们为凹点寻找对应的切割点时，<br>一味寻找最近的切割点，忽略了搜索路径中其它凹点的存在</p>
<p>于是我们只需要加上一些判断：</p>
<p>对边<code>s0</code>搜索切割点，某时刻搜索到点<code>pt</code>，同时搜索路径中出现过另一个凸点<code>pa</code><br>如果点<code>pt</code>符合<code>s0</code>的切割点要求，但是路径中并没有出现过满足<code>pa</code>的切割点，则放弃<code>pt</code></p>
<p>如此，在正向搜索的时候不会出现交叉边，如DEMO中<code>Slice B</code>所示</p>
<p><strong>全文完</strong></p>

</article>

      <footer>
  <div class="footer">
    &copy; 2015-2016 Yewmint, All rights reserved.
  </div>
</footer>

    </div>
  </body>
</html>
