<!DOCTYPE html>
<html lang="zh-CN">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <link rel="shortcut icon" href="/img/favicon.ico">
  <link rel="stylesheet" href="/css/normalize.css">
  <link rel="stylesheet" href="/css/Torpedo.css">
  <link rel="stylesheet" href="/css/yewmint.css">
  <title>2D Visible Area | Yewth</title>
</head>

  <body>
    <div id="wrapper">
      <header id="page-header">
  <div id="header-title">
    <a href="/">Yewth</a>
  </div>
  <div id="header-nav">
    <ul>
      
        <li><a target="_blank" class="menu-item " href="/">Index</a></li>
      
        <li><a target="_blank" class="menu-item " href="https://github.com/yewmint">GITHUB</a></li>
      
    </ul>
</header>

      <article class="article">
  <h1 id="-" class="article-title">2D Visible Area</h1>
  <p class="article-date">2017-02-22</p>
  <h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>The author of indie game <code>Nothing to Hide</code>, Nicky Case, released<br>a note <a href="http://ncase.me/sight-and-light/" target="_blank" rel="external">SIGHT&amp;LIGHT</a> telling how to<br>create a 2D visible area effect. This is really a fantastic technique.</p>
<p>However in my words, the writting style of author is a little bit poor.<br>Many details of this technique has not been expressed properly and<br>exhaustively. So I might narrate it once again.</p>
<p>In this article, I improve the algorithm used to detect intersection since the<br>algorithm from Nicky may return NaN intersecion and doesn’t work when <code>dx == 0</code>.</p>
<a id="more"></a>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>Click <a href="/demos/raycast.html">Demo</a> which is coded by myself.</p>
<p>Source code is <a href="https://github.com/yewmint/ViewportDetection" target="_blank" rel="external">here</a>.</p>
<p>Move your cursor, you’ll see a pink area which is your calculated viewport.</p>
<h2 id="Intersection-between-Ray-and-Wall"><a href="#Intersection-between-Ray-and-Wall" class="headerlink" title="Intersection between Ray and Wall"></a>Intersection between Ray and Wall</h2><p>First step is to get intersection between ray and wall.<br>Take a look at parametric equation of a segment:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">x = x0 + dx * t</div><div class="line">y = y0 + dy * t</div><div class="line">(0 &lt;= t &lt;= 1)</div></pre></td></tr></table></figure>
<p>Given 2 segments <code>s1</code> and <code>s2</code>, the intersection satisfy equations:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">s1_x = s2_x</div><div class="line">s1_y = s2_y</div></pre></td></tr></table></figure>
<p>Which is equivalent to:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">s1_dx * s1_t - s2_dx * s2_t = s2_x0 - s1_x0</div><div class="line">s1_dy * s1_t - s2_dy * s2_t = s2_y0 - s1_y0</div></pre></td></tr></table></figure>
<p>Solve equation using matrix algebra:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">H = s2_dx * s1_dy - s1_dx * s2_dy</div><div class="line">H_s1 = s2_dx * (s2_y0 - s1_y0) - s2_dy * (s2_x0 - s1_x0)</div><div class="line">H_s2 = s1_dx * (s2_y0 - s1_y0) - s1_dy * (s2_x0 - s1_x0)</div><div class="line"></div><div class="line">s1_t = H_s1 / H</div><div class="line">s2_t = H_s2 / H</div></pre></td></tr></table></figure>
<p><code>H == 0</code> means <code>s1</code> and <code>s2</code> are parallel or overlap, ignore this case.</p>
<p>Then if you manage to get intersections between a ray and all walls you<br>will have a closest intersection which is the edge of your sight.</p>
<p>Note that <code>t</code> of a segment range between 0 and 1, <code>t</code> of a ray isn’t less<br>than 0.</p>
<h2 id="Feature-Point"><a href="#Feature-Point" class="headerlink" title="Feature Point"></a>Feature Point</h2><p>Can we send rays into all directions and get our view port?</p>
<p>In fact we can’t. Even though we send 360 rays, the gap between 2 adjacent rays<br>will looks unexpectedly drastic conspicuous which leads to a stange view port.<br>Demo of Nicky has shown what it looks like.</p>
<p>To solve this issue, we notice that it’s no need to send rays into all<br>directions. We can just send rays into all corner points. Intersections<br>of these rays are called <strong>Feature Points</strong>.</p>
<p>Here comes second issue, how about the area behind a corner which is actually<br>visible? In case of this circumstance, besides a ray to a corner point, we send<br>2 extra rays which contain a tiny angle offset (radians +- 0.00001)<br>to detect visible area behind a corner.</p>
<p>So far we are able to get all feature points of our view port.</p>
<h2 id="Sorting"><a href="#Sorting" class="headerlink" title="Sorting"></a>Sorting</h2><p>In order to paint view port correctly, we should sort all feature points to<br>create a polygon.</p>
<p>However if you simply sort all intersections using their angle, the output<br>polygon will looks strange. Beacause the angle of a ray is quite similar to<br>those of its 2 siblings rays which may leads to error in sorting.</p>
<p>So we combine a ray and its siblings into a group, then sort all groups using<br>their angles.</p>
<p>Now we fianlly get our view port!</p>
<h2 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h2><p>Now that we have view port in RAM, it’s time to draw it in our browser.</p>
<p><code>canvas</code> tag allows us to draw graphics in browser. Create a HTML file and<br>insert <code>canvas</code> in <code>body</code> tag.</p>
<p>In coffee-script, we init canvas:</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">canvas = <span class="built_in">document</span>.getElementById <span class="string">"ray-canvas"</span></div><div class="line">ctx = canvas.getContext <span class="string">"2d"</span></div></pre></td></tr></table></figure>
<p><code>ctx</code> is the object we used to draw lines and circles:</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">ctx.beginPath()</div><div class="line">ctx.strokeStyle = &quot;#888888&quot;</div><div class="line">ctx.moveTo 0, 0</div><div class="line">ctx.lineTo 200, 100</div><div class="line">ctx.stroke()</div><div class="line"></div><div class="line">ctx.beginPath()</div><div class="line">ctx.fillStyle = &quot;#ff0000&quot;</div><div class="line">ctx.arc 95, 50, 40, 0, 2 * Math.PI</div><div class="line">ctx.fill()</div></pre></td></tr></table></figure>
<p>Now we have our view port painted in our browser.</p>
<p><strong>THE END</strong></p>

</article>

      <footer>
  <div class="footer">
    &copy; 2015-2016 Yewmint, All rights reserved.
  </div>
</footer>

    </div>
  </body>
</html>
